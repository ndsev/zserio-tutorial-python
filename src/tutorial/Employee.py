"""
Automatically generated by Zserio Python extension version 2.2.0.
Generator setup: writerCode, pubsubCode, serviceCode, sqlCode.
"""

import typing
import zserio

import tutorial.Experience
import tutorial.Role

class Employee:
    def __init__(
            self,
            age_: int = int(),
            name_: str = str(),
            salary_: int = int(),
            bonus_: typing.Optional[int] = None,
            role_: typing.Union[tutorial.Role.Role, None] = None,
            skills_: typing.Optional[typing.List[tutorial.Experience.Experience]] = None) -> None:
        self._age_ = age_
        self._name_ = name_
        self._salary_ = salary_
        self._bonus_ = bonus_
        self._role_ = role_
        if skills_ is None:
            self._skills_ = None
        else:
            self._skills_ = zserio.array.Array(zserio.array.ObjectArrayTraits(self._elementCreator_skills), skills_, isAuto=True)

    @classmethod
    def fromReader(
            cls: typing.Type['Employee'],
            reader: zserio.BitStreamReader) -> 'Employee':
        instance = cls()
        instance.read(reader)

        return instance

    def __eq__(self, other: object) -> bool:
        if isinstance(other, Employee):
            return (self._age_ == other._age_ and
                    self._name_ == other._name_ and
                    self._salary_ == other._salary_ and
                    (not self.isBonusUsed() or self._bonus_ == other._bonus_) and
                    self._role_ == other._role_ and
                    (not self.isSkillsUsed() or self._skills_ == other._skills_))

        return False

    def __hash__(self) -> int:
        result = zserio.hashcode.HASH_SEED
        result = zserio.hashcode.calcHashCode(result, hash(self._age_))
        result = zserio.hashcode.calcHashCode(result, hash(self._name_))
        result = zserio.hashcode.calcHashCode(result, hash(self._salary_))
        if self.isBonusUsed():
            result = zserio.hashcode.calcHashCode(result, hash(self._bonus_))
        result = zserio.hashcode.calcHashCode(result, hash(self._role_))
        if self.isSkillsUsed():
            result = zserio.hashcode.calcHashCode(result, hash(self._skills_))

        return result

    def getAge(self) -> int:
        return self._age_

    def setAge(self, age_: int) -> None:
        self._age_ = age_

    def getName(self) -> str:
        return self._name_

    def setName(self, name_: str) -> None:
        self._name_ = name_

    def getSalary(self) -> int:
        return self._salary_

    def setSalary(self, salary_: int) -> None:
        self._salary_ = salary_

    def getBonus(self) -> typing.Optional[int]:
        return self._bonus_

    def setBonus(self, bonus_: typing.Optional[int]) -> None:
        self._bonus_ = bonus_

    def isBonusUsed(self) -> bool:
        return not self._bonus_ is None

    def getRole(self) -> typing.Union[tutorial.Role.Role, None]:
        return self._role_

    def setRole(self, role_: typing.Union[tutorial.Role.Role, None]) -> None:
        self._role_ = role_

    def getSkills(self) -> typing.Optional[typing.List[tutorial.Experience.Experience]]:
        return None if self._skills_ is None else self._skills_.getRawArray()

    def setSkills(self, skills_: typing.Optional[typing.List[tutorial.Experience.Experience]]) -> None:
        if skills_ is None:
            self._skills_ = None
        else:
            self._skills_ = zserio.array.Array(zserio.array.ObjectArrayTraits(self._elementCreator_skills), skills_, isAuto=True)

    def isSkillsUsed(self) -> bool:
        return self.getRole() == tutorial.Role.Role.DEVELOPER

    def bitSizeOf(self, bitPosition: int = 0) -> int:
        endBitPosition = bitPosition
        endBitPosition += 8
        endBitPosition += zserio.bitsizeof.getBitSizeOfString(self._name_)
        endBitPosition += 16
        endBitPosition += 1
        if self.isBonusUsed():
            endBitPosition += 16
        endBitPosition += self._role_.bitSizeOf(endBitPosition)
        if self.isSkillsUsed():
            endBitPosition += self._skills_.bitSizeOf(endBitPosition)

        return endBitPosition - bitPosition

    def initializeOffsets(self, bitPosition: int) -> int:
        endBitPosition = bitPosition
        endBitPosition += 8
        endBitPosition += zserio.bitsizeof.getBitSizeOfString(self._name_)
        endBitPosition += 16
        endBitPosition += 1
        if self.isBonusUsed():
            endBitPosition += 16
        endBitPosition = self._role_.initializeOffsets(endBitPosition)
        if self.isSkillsUsed():
            endBitPosition = self._skills_.initializeOffsets(endBitPosition)

        return endBitPosition

    def read(self, reader: zserio.BitStreamReader) -> None:
        self._age_ = reader.readBits(8)
        # check constraint
        if not (self.getAge() <= 65):
            raise zserio.PythonRuntimeException("Constraint violated for field Employee.age!")

        self._name_ = reader.readString()

        self._salary_ = reader.readBits(16)

        if reader.readBool():
            self._bonus_ = reader.readBits(16)

        self._role_ = tutorial.Role.Role.fromReader(reader)

        if self.isSkillsUsed():
            self._skills_ = zserio.array.Array.fromReader(zserio.array.ObjectArrayTraits(self._elementCreator_skills), reader, isAuto=True)

    def write(self, writer: zserio.BitStreamWriter, *, callInitializeOffsets: bool = True) -> None:
        del callInitializeOffsets

        # check constraint
        if not (self.getAge() <= 65):
            raise zserio.PythonRuntimeException("Constraint violated for field Employee.age!")
        writer.writeBits(self._age_, 8)

        writer.writeString(self._name_)

        writer.writeBits(self._salary_, 16)

        if self.isBonusUsed():
            writer.writeBool(True)
            writer.writeBits(self._bonus_, 16)
        else:
            writer.writeBool(False)

        self._role_.write(writer)

        if self.isSkillsUsed():
            self._skills_.write(writer)

    def _elementCreator_skills(self, reader: zserio.BitStreamReader, _index: int) -> tutorial.Experience.Experience:
        return tutorial.Experience.Experience.fromReader(reader)
